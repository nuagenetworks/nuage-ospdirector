diff -ruN /usr/share/openstack-tripleo-heat-templates-original/docker/services/neutron-api.yaml /usr/share/openstack-tripleo-heat-templates/docker/services/neutron-api.yaml
--- /usr/share/openstack-tripleo-heat-templates-original/docker/services/neutron-api.yaml	2019-04-03 12:39:54.864175754 -0400
+++ /usr/share/openstack-tripleo-heat-templates/docker/services/neutron-api.yaml	2019-04-03 12:41:11.986175754 -0400
@@ -244,6 +244,11 @@
           when:
             - step|int == 6
             - is_bootstrap_node|bool
+        - name: Nuage package update
+          shell: yum -y update  nuage-*
+          when:
+            - step|int == 6
+            - is_bootstrap_node|bool
         - name: Neutron package update workaround
           yum: name=python-networking-odl state=latest
           when:
diff -ruN /usr/share/openstack-tripleo-heat-templates-original/puppet/services/ironic-conductor.yaml /usr/share/openstack-tripleo-heat-templates/puppet/services/ironic-conductor.yaml
--- /usr/share/openstack-tripleo-heat-templates-original/puppet/services/ironic-conductor.yaml	2019-04-03 12:39:54.940175754 -0400
+++ /usr/share/openstack-tripleo-heat-templates/puppet/services/ironic-conductor.yaml	2019-04-03 12:41:11.985175754 -0400
@@ -161,6 +161,10 @@
   MonitoringSubscriptionIronicConductor:
     default: 'overcloud-ironic-conductor'
     type: string
+  IronicDhcpProvider:
+    description: Which DHCP provider to use
+    default: ''
+    type: string
 
 resources:
   IronicBase:
@@ -176,6 +180,7 @@
       IronicDebug: {get_param: IronicDebug}
 
 conditions:
+  dhcp_provider_unset: {equals : [{get_param: IronicDhcpProvider}, '']}
   service_debug:
     or:
       - equals: [{get_param: IronicDebug}, 'true']
@@ -192,6 +197,11 @@
       config_settings:
         map_merge:
           - get_attr: [IronicBase, role_data, config_settings]
+          -
+            if:
+            - dhcp_provider_unset
+            - {}
+            - ironic::conductor::dhcp_provider: {get_param: IronicDhcpProvider}
           - ironic::conductor::api_url: {get_param: [EndpointMap, IronicInternal, uri_no_suffix]}
             ironic::conductor::cleaning_disk_erase: {get_param: IronicCleaningDiskErase}
             ironic::conductor::cleaning_network: {get_param: IronicCleaningNetwork}
diff -ruN /usr/share/openstack-tripleo-heat-templates-original/puppet/services/neutron-compute-plugin-nuage.yaml /usr/share/openstack-tripleo-heat-templates/puppet/services/neutron-compute-plugin-nuage.yaml
--- /usr/share/openstack-tripleo-heat-templates-original/puppet/services/neutron-compute-plugin-nuage.yaml	2019-04-03 12:39:54.946175754 -0400
+++ /usr/share/openstack-tripleo-heat-templates/puppet/services/neutron-compute-plugin-nuage.yaml	2019-04-03 12:41:11.987175754 -0400
@@ -75,6 +75,25 @@
     description: Support for non-default MTU configured on each Compute node
     type: string
     default: ''
+  OvsHwOffload:
+    default: false
+    description: |
+      Enable OVS Hardware Offload.
+    type: boolean
+
+resources:
+
+  RoleParametersValue:
+    type: OS::Heat::Value
+    properties:
+      type: json
+      value:
+        map_replace:
+          - map_replace:
+            - nuage::vrs::enable_hw_offload: OvsHwOffload
+            - values: {get_param: [RoleParameters]}
+          - values:
+              OvsHwOffload: {get_param: OvsHwOffload}
 
 outputs:
   role_data:
@@ -82,25 +101,27 @@
     value:
       service_name: neutron_compute_plugin_nuage
       config_settings:
-        nuage::vrs::active_controller: {get_param: NuageActiveController}
-        nuage::vrs::standby_controller: {get_param: NuageStandbyController}
-        nuage::vrs::bridge_mtu: {get_param: NuageBridgeMTU}
-        nuage::metadataagent::metadata_port: {get_param: NuageMetadataPort}
-        nuage::metadataagent::nova_metadata_port: {get_param: NuageNovaMetadataPort}
-        nuage::metadataagent::metadata_secret: {get_param: NuageMetadataProxySharedSecret}
-        nuage::metadataagent::nova_client_version: {get_param: NuageNovaClientVersion}
-        nuage::metadataagent::nova_os_username: {get_param: NuageNovaOsUsername}
-        nuage::metadataagent::metadata_agent_start_with_ovs: {get_param: NuageMetadataAgentStartWithOvs}
-        nuage::metadataagent::nova_api_endpoint_type: {get_param: NuageNovaApiEndpoint}
-        nuage::metadataagent::nova_region_name: {get_param: NuageNovaRegionName}
-        tripleo::profile::base::neutron::agents::nuage::nova_os_tenant_name: 'service'
-        tripleo::profile::base::neutron::agents::nuage::nova_os_password: {get_param: NovaPassword}
-        tripleo::profile::base::neutron::agents::nuage::nova_auth_ip: {get_param: [EndpointMap, KeystoneInternal, host]}
-        tripleo.neutron_compute_plugin_nuage.firewall_rules:
-          '118 neutron vxlan networks':
-            proto: 'udp'
-            dport: 4789
-          '100 metadata agent':
-            dport: {get_param: NuageMetadataPort}
+        map_merge:
+          - get_attr: [RoleParametersValue, value]
+          - nuage::vrs::active_controller: {get_param: NuageActiveController}
+            nuage::vrs::standby_controller: {get_param: NuageStandbyController}
+            nuage::vrs::bridge_mtu: {get_param: NuageBridgeMTU}
+            nuage::metadataagent::metadata_port: {get_param: NuageMetadataPort}
+            nuage::metadataagent::nova_metadata_port: {get_param: NuageNovaMetadataPort}
+            nuage::metadataagent::metadata_secret: {get_param: NuageMetadataProxySharedSecret}
+            nuage::metadataagent::nova_client_version: {get_param: NuageNovaClientVersion}
+            nuage::metadataagent::nova_os_username: {get_param: NuageNovaOsUsername}
+            nuage::metadataagent::metadata_agent_start_with_ovs: {get_param: NuageMetadataAgentStartWithOvs}
+            nuage::metadataagent::nova_api_endpoint_type: {get_param: NuageNovaApiEndpoint}
+            nuage::metadataagent::nova_region_name: {get_param: NuageNovaRegionName}
+            tripleo::profile::base::neutron::agents::nuage::nova_os_tenant_name: 'service'
+            tripleo::profile::base::neutron::agents::nuage::nova_os_password: {get_param: NovaPassword}
+            tripleo::profile::base::neutron::agents::nuage::nova_auth_ip: {get_param: [EndpointMap, KeystoneInternal, host]}
+            tripleo.neutron_compute_plugin_nuage.firewall_rules:
+              '118 neutron vxlan networks':
+                proto: 'udp'
+                dport: 4789
+              '100 metadata agent':
+                dport: {get_param: NuageMetadataPort}
       step_config: |
         include ::tripleo::profile::base::neutron::agents::nuage
diff -ruN /home/stack/templates-original/mellanox_fw_update.yaml /home/stack/templates/mellanox_fw_update.yaml
--- /home/stack/templates-original/mellanox_fw_update.yaml	1969-12-31 19:00:00.000000000 -0500
+++ /home/stack/templates/mellanox_fw_update.yaml	2019-04-22 07:41:31.796323634 -0400
@@ -0,0 +1,409 @@
+heat_template_version: queens
+
+description: >
+  This's a temporary workaround for upgrading Mellanox FW
+  and configuring Sriov in the FW
+parameters:
+  BIN_DIR_URL:
+    type: string
+    default: ''
+    description: 'URL of a directory containing Mellanox NIC Firmware'
+  FORCE_UPDATE:
+    type: boolean
+    default: False
+    description: "Force update the fw even if it's older version"
+  NUM_OF_VFS:
+    type: number
+    default: 32
+    description: 'Max number of vfs'
+  SRIOV_EN:
+    type: boolean
+    default: True
+    description: 'Enable/Disable Sriov'
+  LINK_TYPE:
+    type: string
+    default: 'eth'
+    description: 'Link type ["eth", "ib"]'
+  ESWITCH_IPV4_TTL_MODIFY_ENABLE:
+    type: boolean
+    default: True
+    description: 'Enable TTL modification by E-Switch'
+  PRIO_TAG_REQUIRED_EN:
+    type: boolean
+    default: True
+    description: 'Priority tag required'
+
+resources:
+  userdata:
+    type: OS::Heat::MultipartMime
+    properties:
+      parts:
+      - config: {get_resource: mellanox_fw_update}
+
+  mellanox_fw_update:
+    type: OS::Heat::SoftwareConfig
+    properties:
+      config:
+        str_replace:
+          template: |
+            #!/usr/bin/env python
+            from HTMLParser import HTMLParser
+            import logging
+            import os
+            import re
+            import shutil
+            import tempfile
+            import threading
+            import urllib2
+            from oslo_concurrency import processutils
+            FW_VERSION_REGEX = r'FW Version:\s*\t*(?P<fw_ver>\d+\.\d+\.\d+)'
+            PSID_REGEX = r'PSID:\s*\t*(?P<psid>\w+)'
+            _FORCE_UPDATE = $FORCE_UPDATE
+            _BIN_DIR_URL = "$BIN_DIR_URL"
+            logging.basicConfig(
+                filename='/var/log/mellnox_fw_update.log',
+                filemode='w',
+                level=logging.DEBUG)
+            LOG = logging.getLogger("mellnox_fw_update")
+            _MLX_CONFIG = {
+                "SRIOV_EN": "$SRIOV_EN",
+                "NUM_OF_VFS": "$NUM_OF_VFS",
+                "LINK_TYPE_P1": "$LINK_TYPE",
+                "LINK_TYPE_P2": "$LINK_TYPE",
+                "ESWITCH_IPV4_TTL_MODIFY_ENABLE": "$ESWITCH_IPV4_TTL_MODIFY_ENABLE",
+                "PRIO_TAG_REQUIRED_EN": "$PRIO_TAG_REQUIRED_EN"
+            }
+            def run_command(*cmd, **kwargs):
+                try:
+                    out, err = processutils.execute(*cmd, **kwargs)
+                except processutils.ProcessExecutionError as e:
+                    LOG.error("Failed to execute %s, %s", ' '.join(cmd), str(e))
+                    raise e
+                if err:
+                    LOG.error(err)
+                    exit(1)
+                LOG.debug(out)
+                return out
+            def parse_mstflint_query_output(out):
+                """ Parse Mstflint query output
+                For now just extract 'FW Version' and 'PSID'
+                :param out: mstflint query output
+                :return: dictionary of query attributes
+                """
+                query_info = {}
+                for line in out.split('\n'):
+                    fw_ver = re.match(FW_VERSION_REGEX, line)
+                    psid = re.match(PSID_REGEX, line)
+                    if fw_ver:
+                        query_info["fw_ver"] = fw_ver.group('fw_ver')
+                    if psid:
+                        query_info["psid"] = psid.group('psid')
+                return query_info
+            class MlnxDevices(object):
+                """ Discover and retrieve Mellanox PCI devices.
+                Can be used as an iterator once discover has been called.
+                """
+                def __init__(self):
+                    self._devs = []
+                def discover(self):
+                    """ Discover Mellanox devices in the system. (first PF of every device)
+                    :return: None
+                    """
+                    if self._devs:
+                        return self._devs
+                    devs = []
+                    cmd = ['lspci', '-d', '15b3:']
+                    out = run_command(*cmd)
+                    for line in out.split('\n'):
+                        if not line:
+                            continue
+                        dev = line.split()[0]
+                        if dev.endswith('.0'):
+                            devs.append(dev)
+                    self._devs = devs
+                    LOG.info("Found Mellanox devices: %s", devs)
+                def __len__(self):
+                    return len(self._devs)
+                def __iter__(self):
+                    return self._devs.__iter__()
+                def __next__(self):
+                    return self._devs.__iter__()
+                def next(self):
+                    return self.__next__()
+            class MlnxDeviceConfig(object):
+                """ Get/Set Mellanox Device configurations
+                """
+                def __init__(self, pci_dev):
+                    self.pci_dev = pci_dev
+                def _mstconfig_parse_data(self, data):
+                    # Parsing the mstconfig out to json
+                    data = list(filter(None, data.split('\n')))
+                    r = {}
+                    c = 0
+                    for line in data:
+                        c += 1
+                        if 'Configurations:' in line:
+                            break
+                    for i in range(c, len(data)):
+                        d = list(filter(None, data[i].strip().split()))
+                        r[d[0]] = d[1]
+                    return r
+                def get_device_conf_dict(self):
+                    """ Get device Configurations
+                    :return:  dict {"PARAM_NAME": "Param value", ....}
+                    """
+                    LOG.info("Getting configurations for device: %s" % self.pci_dev)
+                    out = run_command("mstconfig", "-d", self.pci_dev, "q")
+                    return self._mstconfig_parse_data(out)
+                def set_config(self, conf_dict):
+                    """ Set device configurations
+                    :param conf_dict: a dictionary of:
+                                      {"PARAM_NAME": "Param value to set", ...}
+                    :return: None
+                    """
+                    current_mlx_config = self.get_device_conf_dict()
+                    params_to_set = []
+                    for key, value in conf_dict.items():
+                        if current_mlx_config.get(key) and value.lower(
+                        ) not in current_mlx_config.get(key).lower():
+                            # Aggregate all configurations required to be modified
+                            params_to_set.append("%s=%s" % (key, value))
+                    if params_to_set:
+                        LOG.info("Setting configurations for device: %s" % self.pci_dev)
+                        run_command("mstconfig", "-d", self.pci_dev, "-y",
+                                    "set", *params_to_set)
+                        LOG.info("Set device configurations: Setting %s done successfully",
+                                 " ".join(params_to_set))
+                    else:
+                        LOG.info("Set device configurations: No operation required")
+            class MlnxFirmwareBinary(object):
+                def __init__(self, local_bin_path):
+                    self.bin_path = local_bin_path
+                    self.image_info = {}
+                def get_info(self):
+                    """ Get firmware information from binary
+                    Caller should wrap this call under try catch to skip non compliant
+                    firmware binaries.
+                    :return: dict of firmware image attributes
+                    """
+                    if self.image_info.get('file_path', '') == self.bin_path:
+                        return self.image_info
+                    self.image_info = {'file_path': self.bin_path}
+                    cmd = ['mstflint', '-i', self.bin_path, 'query']
+                    out = run_command(*cmd)
+                    self.image_info.update(parse_mstflint_query_output(out))
+                    # Note(adrianc): deep copy ?
+                    return self.image_info
+            class MlnxFirmwareBinariesFetcher(object):
+                """ A class for fetching firmware binaries form a directory
+                provided by a URL link
+                Note: URL MUST point to a directory and end with '/'
+                e.g http://www.mysite.com/mlnx_bins/
+                """
+                dest_dir = tempfile.mkdtemp(suffix="tripleo_mlnx_firmware")
+                class FileHTMLParser(HTMLParser):
+                    """ A crude HTML Parser to extract files from an HTTP response.
+                    """
+                    def __init__(self, suffix):
+                        # HTMLParser is Old style class dont use super() method
+                        HTMLParser.__init__(self)
+                        self.matches = []
+                        self.suffix = suffix
+                    def handle_starttag(self, tag, attrs):
+                        for name, val in attrs:
+                            if name == 'href' and val.endswith(self.suffix):
+                                self.matches.append(val)
+                def __init__(self, url):
+                    self.url = url
+                def __del__(self):
+                    self._cleanup_dest_dir()
+                def _cleanup_dest_dir(self):
+                    if os.path.exists(MlnxFirmwareBinariesFetcher.dest_dir):
+                        shutil.rmtree(MlnxFirmwareBinariesFetcher.dest_dir)
+                def _get_file_from_url(self, file_name):
+                    try:
+                        full_path = self.url + "/" + file_name
+                        LOG.info("Downloading file: %s to %s", full_path,
+                                 MlnxFirmwareBinariesFetcher.dest_dir)
+                        url_data = urllib2.urlopen(full_path)
+                    except urllib2.HTTPError as e:
+                        LOG.error("Failed to download data: %s", str(e))
+                        raise e
+                    dest_file_path = os.path.join(MlnxFirmwareBinariesFetcher.dest_dir,
+                                                  file_name)
+                    with open(dest_file_path, 'wb') as f:
+                        f.write(url_data.read())
+                    return dest_file_path
+                def _get_file_create_bin_obj(self, file_name, fw_bins):
+                    """ This wrapper method will download a firmware binary,
+                    create MlnxFirmwareBinary object and append to the provided
+                    fw_bins list.
+                    :return: None
+                    """
+                    try:
+                        dest_file_path = self._get_file_from_url(file_name)
+                        fw_bin = MlnxFirmwareBinary(dest_file_path)
+                        # Note(adrianc): Pre query image, to skip incompatible files
+                        # in case of Error
+                        fw_bin.get_info()
+                        fw_bins.append(fw_bin)
+                    except Exception as e:
+                        LOG.warning("Failed to download and query %s, skipping file. "
+                                    "%s", file_name, str(e))
+                def get_firmware_binaries(self):
+                    """ Get Firmware binaries
+                    :return: list containing the files downloaded
+                    """
+                    # get list of files
+                    # download into dest_dir
+                    # for each file, create MlnxFirmwareBinary
+                    # return list of the MlnxFirmwareBinary
+                    if not self.url.endswith('/'):
+                        LOG.error("Bad URL provided (%s), expected URL to be a directory",
+                                  self.url)
+                        raise RuntimeError('Failed to get firmware binaries, '
+                                           'expected directory URL path '
+                                           '(e.g "http://<your_ip>/mlnx_bins/"). '
+                                           'Given URL path: %s', self.url)
+                    try:
+                        index_data = urllib2.urlopen(_BIN_DIR_URL).read()
+                    except urllib2.HTTPError as err:
+                        LOG.error(err)
+                        raise err
+                    parser = MlnxFirmwareBinariesFetcher.FileHTMLParser(suffix=".bin")
+                    parser.feed(index_data)
+                    parser.close()
+                    if not parser.matches:
+                        LOG.warning("No bin Files found in the provided URL: %s", self.url)
+                    fw_bins = []
+                    threads = []
+                    for file_name in parser.matches:
+                        # TODO(adrianc) fetch files async with co-routines,
+                        # may need to limit thread count
+                        t = threading.Thread(target=self._get_file_create_bin_obj,
+                                             args=(file_name, fw_bins))
+                        t.start()
+                        threads.append(t)
+                    for t in threads:
+                        t.join()
+                    return fw_bins
+            class MlnxDevFirmwareOps(object):
+                """ Perform various Firmware related operations on device
+                """
+                def __init__(self, dev):
+                    self.dev = dev
+                    self.dev_info = {}
+                def query_device(self):
+                    """ Get firmware information from device
+                    :return: dict of firmware image attributes
+                    """
+                    if self.dev_info.get('device', '') == self.dev:
+                        return self.dev_info
+                    self.dev_info = {'device': self.dev}
+                    cmd = ['mstflint', '-d', self.dev, '-qq', 'query']
+                    out = run_command(*cmd)
+                    self.dev_info.update(parse_mstflint_query_output(out))
+                    # Note(adrianc): deep copy ?
+                    return self.dev_info
+                def need_update(self, image_info):
+                    """ Check if device requires firmware update
+                    :param image_info: image_info dict as returned from
+                                       MlnxFirmwareBinary.get_info()
+                    :return: bool, True if update is needed
+                    """
+                    if not self.dev_info:
+                        self.query_device()
+                    return self.dev_info['fw_ver'] < image_info['fw_ver']
+                def burn_firmware(self, image_path):
+                    """ Burn firmware on device
+                    :param image_path: firmware binary file path
+                    :return: None
+                    """
+                    LOG.info("Updating firmware image (%s) for device: %s",
+                             image_path, self.dev)
+                    cmd = ["mstflint", "-d", self.dev, "-i", image_path,
+                           "-y", "burn"]
+                    run_command(*cmd)
+                    LOG.info("Device %s: Successfully updated.", self.dev)
+            def check_prereq():
+                """ Check that all needed tools are available in the system.
+                :return: None
+                """
+                try:
+                    # check for mstflint
+                    run_command('mstflint', '-v')
+                    # check for mstconfig
+                    run_command('mstconfig', '-v')
+                    # check for lspci
+                    run_command('lspci', '--version')
+                except Exception as e:
+                    LOG.error("Failed Prerequisite check. %s", str(e))
+                    raise e
+            def process_device(pci_dev, psid_map):
+                """ Process a single Mellanox device.
+                Processing pipeline:
+                    - Perform firmware update if required
+                    - Perform device configurations if required
+                :param pci_dev: mellanox PCI device address (String)
+                :param psid_map: dict mapping between PSID and an image_info dict
+                :return: None
+                """
+                try:
+                    LOG.info("Processing Device: %s", pci_dev)
+                    dev_ops = MlnxDevFirmwareOps(pci_dev)
+                    device_config = MlnxDeviceConfig(pci_dev)
+                    dev_query = dev_ops.query_device()
+                    # see if there is a matching bin
+                    dev_psid = dev_query['psid']
+                    if dev_psid in psid_map:
+                        if _FORCE_UPDATE or dev_ops.need_update(psid_map[dev_psid]):
+                            dev_ops.burn_firmware(psid_map[dev_psid]['file_path'])
+                        else:
+                            LOG.info("Firmware update is not required for Device.")
+                    else:
+                        LOG.warning("No firmware binary found for device %s with "
+                                    "PSID: %s, skipping...", pci_dev, dev_psid)
+                    # set device configurations
+                    device_config.set_config(_MLX_CONFIG)
+                    LOG.info("Device %s processed successfully.", pci_dev)
+                except Exception as e:
+                    LOG.error("Failed to process device %s. %s", pci_dev, str(e))
+            def main():
+                check_prereq()
+                # discover devices
+                mlnx_devices = MlnxDevices()
+                mlnx_devices.discover()
+                # get binaries
+                binary_getter = MlnxFirmwareBinariesFetcher(_BIN_DIR_URL)
+                fw_binaries = binary_getter.get_firmware_binaries()
+                # prep psid map
+                psid_map = {}
+                for fw_bin in fw_binaries:
+                    image_info = fw_bin.get_info()
+                    psid_map[image_info['psid']] = image_info
+                threads = []
+                for pci_dev in mlnx_devices:
+                    t = threading.Thread(target=process_device, args=(pci_dev, psid_map))
+                    t.start()
+                    threads.append(t)
+                for t in threads:
+                    t.join()
+            if __name__ == '__main__':
+                main()
+          params:
+            $BIN_DIR_URL: {get_param: BIN_DIR_URL}
+            $FORCE_UPDATE: {get_param: FORCE_UPDATE}
+            $NUM_OF_VFS: {get_param: NUM_OF_VFS}
+            $SRIOV_EN: {get_param: SRIOV_EN}
+            $LINK_TYPE: {get_param: LINK_TYPE}
+            $ESWITCH_IPV4_TTL_MODIFY_ENABLE: {get_param: ESWITCH_IPV4_TTL_MODIFY_ENABLE}
+            $PRIO_TAG_REQUIRED_EN: {get_param: PRIO_TAG_REQUIRED_EN}
+
+
+outputs:
+  # This means get_resource from the parent template will get the userdata, see:
+  # http://docs.openstack.org/developer/heat/template_guide/composition.html#making-your-template-resource-more-transparent
+  # Note this is new-for-kilo, an alternative is returning a value then using
+  # get_attr in the parent template instead.
+  OS::stack_id:
+    value: {get_resource: userdata}
